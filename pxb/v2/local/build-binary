#!/bin/bash


set -o errexit
set -o xtrace


# ------------------------------------------------------------------------------
# Declare all input variables
# ------------------------------------------------------------------------------
JOB_CMAKE=${JOB_CMAKE:-cmake}
COMPILER=${COMPILER:-default}
CMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE:-RelWithDebInfo}
ASAN_SWITCH=${ASAN_SWITCH:-OFF}
MAKE_OPTS=${MAKE_OPTS:--j$(nproc)}
CMAKE_OPTS=${CMAKE_OPTS:-}
TAG=${TAG:-}

# ------------------------------------------------------------------------------
# set working dir
# ------------------------------------------------------------------------------
mkdir -p ${1:-./build}
WORKDIR=$(cd ${1:-./build}; pwd -P)
INSTALL_DIR=${WORKDIR}/DESTDIR
DOWNLOAD_DIR=${WORKDIR}/source_downloads
mkdir -p ${INSTALL_DIR} ${DOWNLOAD_DIR}
SOURCEDIR=$(cd ${2:-$(dirname $0)/../sources}; pwd -P)


# ------------------------------------------------------------------------------
# download external libs
# ------------------------------------------------------------------------------
wget_loop() {
    local FILE="$1"
    local URL="$2"

    if [[ ! -f "${DOWNLOAD_DIR}/${FILE}" ]]; then
        until wget --progress=dot:giga -O "${DOWNLOAD_DIR}/${FILE}" "${URL}"; do
            echo "sleep before retry"
            sleep 1
        done
    fi
}

# ------------------------------------------------------------------------------
# Set OS/Arch flags
# ------------------------------------------------------------------------------

TARGET_ARCH="$(uname -m)"

export CC=${CC:-gcc}
export CXX=${CXX:-g++}
export CFLAGS=${CFLAGS:-}
export CXXFLAGS=${CXXFLAGS:-}
export MAKE_JFLAG=-j$(nproc)

# ------------------------------------------------------------------------------
# Set compile options
# ------------------------------------------------------------------------------
if [[ "$COMPILER" != "default" ]]; then
    export CC=${COMPILER}
    export CXX=$(echo ${COMPILER} | sed -e 's/gcc/g++/; s/clang/clang++/')
fi

# ------------------------------------------------------------------------------
# set version
# ------------------------------------------------------------------------------
source "${SOURCEDIR}/XB_VERSION"
if [[ -n "$(which git)" ]] && [[ -d "${SOURCEDIR}/.git" ]]; then
    REVISION="$(cd "${SOURCEDIR}"; git rev-parse --short HEAD)"
fi

if [[ "${ASAN_SWITCH}" == "ON" ]]; then
    CMAKE_OPTS=+" -DWITH_ASAN=ON"
    TAG+="-asan"
fi

if [[ "${CMAKE_BUILD_TYPE}" == "Debug" ]]; then
    export BUILD_TYPE=" -DWITH_DEBUG=ON"
    TAG+="-debug"
else
    export BUILD_TYPE=" -DBUILD_CONFIG=xtrabackup_release"
fi

XTRABACKUP_VERSION="${XB_VERSION_MAJOR}.${XB_VERSION_MINOR}.${XB_VERSION_PATCH}${XB_VERSION_EXTRA}"
FULL_PRODUCT_NAME="percona-xtrabackup-${XTRABACKUP_VERSION}-$(uname -s)-$(uname -m)${TAG}"



# ------------------------------------------------------------------------------
# Finaly, compile!
# ------------------------------------------------------------------------------
pushd ${WORKDIR}
    ${JOB_CMAKE} \
        ${BUILD_TYPE} \
        -DDOWNLOAD_BOOST=ON \
        -DWITH_BOOST=${DOWNLOAD_DIR} \
        -DCMAKE_INSTALL_PREFIX=${FULL_PRODUCT_NAME} \
        -DINSTALL_MYSQLTESTDIR=${FULL_PRODUCT_NAME}-test \
        -DINSTALL_MANDIR=${FULL_PRODUCT_NAME}/man \
        -DMYSQL_UNIX_ADDR=/var/run/mysqld/mysqld.sock \
        ${TARGET_CFLAGS:+-DCMAKE_C_FLAGS="${TARGET_CFLAGS}" -DCMAKE_CXX_FLAGS="${TARGET_CFLAGS}"} \
        ${CMAKE_OPTS} \
        ${SOURCEDIR}
    make ${MAKE_OPTS}
    make DESTDIR=${INSTALL_DIR} install > make_install.log
popd

cd ${INSTALL_DIR}/${WORKDIR}/${FULL_PRODUCT_NAME}

LIBLIST="libgcrypt.so libcrypto.so libssl.so libreadline.so libtinfo.so libsasl2.so librtmp.so libssl3.so libsmime3.so libnss3.so libnssutil3.so libplds4.so libplc4.so libnspr4.so"
DIRLIST="bin lib lib/private lib/plugin"

LIBPATH=""

function gather_libs {
local elf_path=$1
for lib in ${LIBLIST}; do
    for elf in $(find ${elf_path} -maxdepth 1 -exec file {} \; | grep 'ELF ' | cut -d':' -f1); do
        IFS=$'\n'
        for libfromelf in $(ldd ${elf} | grep ${lib} | awk '{print $3}'); do
            lib_realpath="$(readlink -f ${libfromelf})"
            lib_realpath_basename="$(basename $(readlink -f ${libfromelf}))"
            lib_without_version_suffix=$(echo ${lib_realpath_basename} | awk -F"." 'BEGIN { OFS = "." }{ print $1, $2}')

            if [ ! -f "lib/private/${lib_realpath_basename}" ] && [ ! -L "lib/private/${lib_without_version_suffix}" ]; then
            
                echo "Copying lib ${lib_realpath_basename}"
                cp ${lib_realpath} lib/private

                if [ ${lib_realpath_basename} != ${lib_without_version_suffix} ] && [ ! -L lib/private/${lib_without_version_suffix} ]; then
                    echo "Symlinking lib from ${lib_realpath_basename} to ${lib_without_version_suffix}"
                    cd lib/private
                    ln -s ${lib_realpath_basename} ${lib_without_version_suffix}
                    cd -
                fi

                patchelf --set-soname ${lib_without_version_suffix} lib/private/${lib_realpath_basename}

                LIBPATH+=" $(echo ${libfromelf} | grep -v $(pwd))"
            fi
        done
        unset IFS
    done
done
}

function set_runpath {
    # Set proper runpath for bins but check before doing anything
    local elf_path=$1
    local r_path=$2
    for elf in $(find ${elf_path} -maxdepth 1 -exec file {} \; | grep 'ELF ' | cut -d':' -f1); do
        echo "Checking LD_RUNPATH for ${elf}"
        if [ -z $(patchelf --print-rpath ${elf}) ]; then
            echo "Changing RUNPATH for ${elf}"
            patchelf --set-rpath ${r_path} ${elf}
        fi
    done
}

function replace_libs {
    local elf_path=$1
    for libpath_sorted in ${LIBPATH}; do
        for elf in $(find ${elf_path} -maxdepth 1 -exec file {} \; | grep 'ELF ' | cut -d':' -f1); do
            LDD=$(ldd ${elf} | grep ${libpath_sorted}|head -n1|awk '{print $1}')
            lib_realpath_basename="$(basename $(readlink -f ${libpath_sorted}))"
            lib_without_version_suffix="$(echo ${lib_realpath_basename} | awk -F"." 'BEGIN { OFS = "." }{ print $1, $2}')"
            if [[ ! -z $LDD  ]]; then
                echo "Replacing lib ${lib_realpath_basename} to ${lib_without_version_suffix} for ${elf}"
                patchelf --replace-needed ${LDD} ${lib_without_version_suffix} ${elf}
            fi
        done
    done
}

function check_libs {
    local elf_path=$1
    for elf in $(find ${elf_path} -maxdepth 1 -exec file {} \; | grep 'ELF ' | cut -d':' -f1); do
        if ! ldd ${elf}; then
            exit 1
        fi
    done
}

if [ ! -d lib/private ]; then
    mkdir -p lib/private
fi
# Gather libs
for DIR in ${DIRLIST}; do
    gather_libs ${DIR}
done

# Set proper runpath
set_runpath bin '$ORIGIN/../lib/private/'
set_runpath lib '$ORIGIN/private/'
set_runpath lib/plugin '$ORIGIN/../private/'
set_runpath lib/private '$ORIGIN'

# Replace libs
for DIR in ${DIRLIST}; do
    replace_libs ${DIR}
done

# Make final check in order to determine any error after linkage
for DIR in ${DIRLIST}; do
    check_libs ${DIR}
done

tar -C ${INSTALL_DIR}/${WORKDIR} --owner=0 --group=0 -czf "${WORKDIR}/${FULL_PRODUCT_NAME}.tar.gz" ${FULL_PRODUCT_NAME}
